@page "/checking"

@inherits OwningComponentBase<ApplicationDbContext>

@using Microsoft.EntityFrameworkCore

<label>
    Auto update
    <input type="checkbox" @bind="autoUpdate" />
</label>
@if (!autoUpdate)
{
    <button class="btn btn-primary" @onclick="@Update">Update</button>
}
<p>Done in last 2 minutes: @doneInLast10Mins</p>
<p>Left: @Left() --- @(doneInLast10Mins == 0 ? "~" : TimeSpan.FromMinutes((Left() / (doneInLast10Mins == 0 ? 1 : doneInLast10Mins)) * 2).ToString())</p>
<table class="table table-bordered">
    <thead>
        <tr>
            <th>Type</th>
            <th>Count</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var i in solutionCountRecords)
        {
            <tr>
                <td>@i.Key</td>
                <td>@i.Value</td>
            </tr>
        }
    </tbody>
</table>
<Olympiad.Admin.Components.Logs @ref="Logs" />

@code {
    Dictionary<Olympiad.Shared.Models.SolutionStatus, int> solutionCountRecords =
        Enum.GetValues(typeof(Olympiad.Shared.Models.SolutionStatus))
            .Cast<Olympiad.Shared.Models.SolutionStatus>()
            .ToDictionary(s => s, _ => 0);

    int doneInLast10Mins = 0;
    bool autoUpdate = false;
    Olympiad.Admin.Components.Logs Logs;

    System.Threading.CancellationTokenSource source = new System.Threading.CancellationTokenSource();
    Task updateTask;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            await Update();
            updateTask = UpdateCycle(source.Token);
        }
    }

    private int Left()
    {
        return
            solutionCountRecords[Olympiad.Shared.Models.SolutionStatus.InProcessing]
            +
            solutionCountRecords[Olympiad.Shared.Models.SolutionStatus.InQueue];
    }

    private async Task UpdateCycle(System.Threading.CancellationToken cancellationToken)
    {
        while (true)
        {
            try
            {
                await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
                cancellationToken.ThrowIfCancellationRequested();
                if (autoUpdate)
                    await Update();
            }
            catch (OperationCanceledException)
            {
                break;
            }
        }
    }

    private async Task Update()
    {
        await Logs.Log($"Updating");
        var dbRecords = (await Service
                .Solutions
                .GroupBy(s => s.Status)
                .Select(s => new { Status = s.Key, Count = s.Count() })
                .ToListAsync())
            .ToDictionary(s => s.Status, v => v.Count);
        foreach (var dbRecord in dbRecords)
        {
            solutionCountRecords[dbRecord.Key] = dbRecord.Value;
        }
        var oldTime = DateTime.UtcNow - TimeSpan.FromMinutes(2);
        doneInLast10Mins = await Service
            .Solutions
            .Where(s => s.CheckedTime > oldTime)
            .CountAsync();
        await Logs.Log($"Updated");
        StateHasChanged();
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        if (disposing)
        {
            source.Cancel();
            updateTask?.Wait(); // TODO update to .net 5, use asyncdispose
        }
    }
}
