@page "/checking"

@inherits OwningComponentBase<ApplicationDbContext>

@inject IQueueChecker QueueChecker

<label>
    Auto update
    <input type="checkbox" @bind="autoUpdate" />
</label>
@if (!autoUpdate)
{
    <button class="btn btn-primary" @onclick="@Update">Update</button>
}
<p>Done in last 2 minutes: @doneInLast10Mins</p>
<p>Left: @Left() --- @(doneInLast10Mins == 0 ? "~" : TimeSpan.FromMinutes((Left() / (doneInLast10Mins == 0 ? 1 : doneInLast10Mins)) * 2).ToString())</p>
<table class="table table-bordered">
    <thead>
        <tr>
            <th>Type</th>
            <th>Count</th>
            <th></th>
        </tr>
    </thead>
    <tbody>
        @foreach (var i in solutionCountRecords)
        {
            <tr>
                <td>@i.Key</td>
                <td>@i.Value</td>
                <td><button class="btn btn-warning" @onclick="() => RecheckAllSolutions(i.Key)">Recheck all solutions</button></td>
            </tr>
        }
    </tbody>
</table>
<NavLink href="checking/recheck">Recheck</NavLink>
<Olympiad.Admin.Components.Logs @ref="Logs" />

@code {
    Dictionary<Olympiad.Shared.Models.SolutionStatus, int> solutionCountRecords =
        Enum.GetValues(typeof(Olympiad.Shared.Models.SolutionStatus))
            .Cast<Olympiad.Shared.Models.SolutionStatus>()
            .ToDictionary(s => s, _ => 0);

    int doneInLast10Mins = 0;
    bool autoUpdate = false;
    Olympiad.Admin.Components.Logs Logs;

    System.Threading.CancellationTokenSource source = new System.Threading.CancellationTokenSource();
    Task updateTask;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            await Update();
            updateTask = UpdateCycle(source.Token);
        }
    }

    private int Left()
    {
        return
            solutionCountRecords[Olympiad.Shared.Models.SolutionStatus.InProcessing]
            +
            solutionCountRecords[Olympiad.Shared.Models.SolutionStatus.InQueue];
    }

    private async Task UpdateCycle(System.Threading.CancellationToken cancellationToken)
    {
        while (true)
        {
            try
            {
                await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
                cancellationToken.ThrowIfCancellationRequested();
                if (autoUpdate)
                    await Update();
            }
            catch (OperationCanceledException)
            {
                break;
            }
        }
    }

    private async Task Update()
    {
        await Logs.Log($"Updating");
        await DoInSync(async () =>
        {
            var dbRecords = (await Service
                .Solutions
                .GroupBy(s => s.Status)
                .Select(s => new { Status = s.Key, Count = s.Count() })
                .ToListAsync())
            .ToDictionary(s => s.Status, v => v.Count);
            foreach (var key in Enum.GetValues(typeof(Olympiad.Shared.Models.SolutionStatus))
            .Cast<Olympiad.Shared.Models.SolutionStatus>())
            {
                solutionCountRecords[key] = 0;
            }
            foreach (var dbRecord in dbRecords)
            {
                solutionCountRecords[dbRecord.Key] = dbRecord.Value;
            }
            var oldTime = DateTime.UtcNow - TimeSpan.FromMinutes(2);
            doneInLast10Mins = await Service
                .Solutions
                .Where(s => s.CheckedTime > oldTime)
                .CountAsync();
        });
        await Logs.Log($"Updated");
        StateHasChanged();
    }

    private async Task RecheckAllSolutions(Olympiad.Shared.Models.SolutionStatus solutionStatus)
    {
        await Logs.Log($"Start rechecking {solutionStatus}");
        await DoInSync(async () =>
        {

            var solutions = await Service.Solutions
                .Where(s => s.Status == solutionStatus)
                .ToListAsync();
            await Logs.Log($"Loaded {solutions.Count} ids");
            foreach (var solution in solutions)
            {
                solution.Status = Olympiad.Shared.Models.SolutionStatus.InQueue;
            }
            await Service.SaveChangesAsync();
            foreach (var solution in solutions)
            {
                QueueChecker.PutInQueue(solution.Id);
            }
        });
        await Logs.Log($"Done recheck work");
    }

    private System.Threading.SemaphoreSlim dbContextSemaphore = new System.Threading.SemaphoreSlim(1, 1);

    private async Task DoInSync(Func<Task>
    action)
    {
        try
        {
            await dbContextSemaphore.WaitAsync();
            await action();
        }
        finally
        {
            dbContextSemaphore.Release();
        }
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        if (disposing)
        {
            source.Cancel();
            updateTask?.Wait(); // TODO update to .net 5, use asyncdispose
        }
    }
}
